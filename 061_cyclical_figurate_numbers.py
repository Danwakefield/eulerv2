#!/usr/bin/python3
# encoding: utf-8
"""
https://projecteuler.net/problem=61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
numbers are all figurate (polygonal) numbers and are generated by the
following formulae:
    Triangle P_3,n = n(n+1)/2
        1, 3, 6, 10, 15, ...
    Square P_4,n = n^2
        1, 4, 9, 16, 25, ...
    Pentagonal P_5,n = n(3n−1)/2
        1, 5, 12, 22, 35, ...
    Hexagonal P_6,n = n(2n−1)
        1, 6, 15, 28, 45, ...
    Heptagonal P_7,n = n(5n−3)/2
        1, 7, 18, 34, 55, ...
    Octagonal P_8,n = n(3n−2)
        1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers:
    8128, 2882, 8281,
has three interesting properties.
The set is cyclic, in that the last two digits of each number is the first two
digits of the next number (including the last number with the first). Each
polygonal type:
    triangle (P_3,127 =8128),
    square (P_4,91 =8281), and
    pentagonal (P_5,44 =2882),
is represented by a different number in the set. This is the
only set of 4-digit numbers with this property.  Find the sum of the only
ordered set of six cyclic 4-digit numbers for which each polygonal type:
    triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is
    represented by a different number in the set.

Answer:
"""
from __future__ import print_function
from utils import (
    timer,
    square_numbers_gen,
    tri_numbers_gen,
    pent_numbers_gen,
    hex_numbers_gen,
    hept_numbers_gen,
    oct_numbers_gen,
    take_between,
    composing_digits,
)

ANSWER = None


def test_answer():
    if ANSWER is None:
        assert 0, 'Not Completed'
    else:
        assert ANSWER == main()


def make_cyclic_map(gen):
    """
    Create maps with the k = the first two digits of the number and values
    a set of two digits suffixes. E.g

    2435 => {
        (2, 4): {(3, 5),}
    }
    """
    d = {}
    for x in gen:
        s = composing_digits(x)
        pre = s[:2]
        suf = s[2:]
        if pre in d:
            d[pre].add(suf)
        else:
            # Add the tuple as an item not individual numbers
            d[pre] = set((suf,))

    # Remove all items from d with only (0, 0) suffixes. These are all dead
    # paths and we dont want to check for them.
    # Copy needed otherwise you get nasty errors from editing the structure
    # being looped over.
    copy_d = d.copy()
    for k, v in copy_d.items():
        if all(x == (0, 0) for x in v):
            del d[k]

    return d


SQUARES = make_cyclic_map(take_between(1010, 9999, square_numbers_gen()))
TRIS = make_cyclic_map(take_between(1010, 9999, tri_numbers_gen()))
PENTS = make_cyclic_map(take_between(1010, 9999, pent_numbers_gen()))
HEXS = make_cyclic_map(take_between(1010, 9999, hex_numbers_gen()))
HEPTS = make_cyclic_map(take_between(1010, 9999, hept_numbers_gen()))
OCTS = make_cyclic_map(take_between(1010, 9999, oct_numbers_gen()))

ORDER = [HEPTS, HEXS, PENTS, TRIS, SQUARES]

@timer
def main():
    for p, s in OCTS.items():
        for g in ORDER:
            if p in g:
                recurse(p, g, ORDER)


def recurse(k, d, l):
    l = l.copy()
    l.remove(d)
    for v in d[k]:
        for g in l:
            if v in g:
                return [k+v].extend(recurse(v, g, l))


if __name__ == '__main__':
    print(main())
