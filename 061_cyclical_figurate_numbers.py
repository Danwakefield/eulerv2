#!/usr/bin/python3
# encoding: utf-8
"""
https://projecteuler.net/problem=61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
numbers are all figurate (polygonal) numbers and are generated by the
following formulae:
    Triangle P_3,n = n(n+1)/2
        1, 3, 6, 10, 15, ...
    Square P_4,n = n^2
        1, 4, 9, 16, 25, ...
    Pentagonal P_5,n = n(3n−1)/2
        1, 5, 12, 22, 35, ...
    Hexagonal P_6,n = n(2n−1)
        1, 6, 15, 28, 45, ...
    Heptagonal P_7,n = n(5n−3)/2
        1, 7, 18, 34, 55, ...
    Octagonal P_8,n = n(3n−2)
        1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers:
    8128, 2882, 8281,
has three interesting properties.
The set is cyclic, in that the last two digits of each number is the first two
digits of the next number (including the last number with the first). Each
polygonal type:
    triangle (P_3,127 =8128),
    square (P_4,91 =8281), and
    pentagonal (P_5,44 =2882),
is represented by a different number in the set. This is the
only set of 4-digit numbers with this property.  Find the sum of the only
ordered set of six cyclic 4-digit numbers for which each polygonal type:
    triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is
    represented by a different number in the set.

Answer:
"""
from __future__ import print_function
from utils import (
    timer,
    square_numbers_gen,
    tri_numbers_gen,
    pent_numbers_gen,
    hex_numbers_gen,
    hept_numbers_gen,
    oct_numbers_gen,
    take_between,
    composing_digits,
)

ANSWER = 28684


def test_answer():
    if ANSWER is None:
        assert 0, 'Not Completed'
    else:
        assert ANSWER == main()


def make_cyclic_map(gen):
    """
    Create maps with the k = the first two digits of the number and values
    a set of two digits suffixes. E.g

    2435 => {
        (2, 4): {(3, 5),}
    }
    """
    d = {}
    for x in gen:
        s = composing_digits(x)
        pre = s[:2]
        suf = s[2:]
        if pre in d:
            d[pre].add(suf)
        else:
            # Add the tuple as an item not individual numbers
            d[pre] = set((suf,))

    # Remove all items from d with only (0, 0) suffixes. These are all dead
    # paths and we dont want to check for them.
    # Copy needed otherwise you get nasty errors from editing the structure
    # being looped over.
    copy_d = d.copy()
    for k, v in copy_d.items():
        if all(x == (0, 0) for x in v):
            del d[k]

    return d


BLAH = {
    'squares': make_cyclic_map(take_between(1010, 9999, square_numbers_gen())),
    'tris': make_cyclic_map(take_between(1010, 9999, tri_numbers_gen())),
    'pents': make_cyclic_map(take_between(1010, 9999, pent_numbers_gen())),
    'hexs': make_cyclic_map(take_between(1010, 9999, hex_numbers_gen())),
    'hepts': make_cyclic_map(take_between(1010, 9999, hept_numbers_gen())),
    'octs': make_cyclic_map(take_between(1010, 9999, oct_numbers_gen())),
}


@timer
def main():
    for k, v in BLAH['squares'].items():
        for x in v:

            used = {'squares': k+x}
            bar = foo(used, x)

            try:
                if len(bar) == 6:
                    total = 0
                    for k, v in bar.items():
                        total += int(''.join(map(str, v)))
                    return total
            except Exception:
                pass


def check(d):
    """
    Checks a dict has cyclic values
    """
    if len(set(d.values())) != 6:
        return False

    # Need seperate copys of the list as we need to remove items
    # as we loop over them.
    l = list(d.values())
    l2 = list(d.values())
    for i, x in enumerate(l):
        for y in l2:
            if y[:2] == x[2:]:
                l2.remove(y)
                break
        else:
            return False

    return True


def foo(used, k):
    """
    recursive function to find cyclic candidates.

    :used: Dict
    :k: 2 item tuple
    """
    for d in BLAH:
        if d in used:
            continue
        elif k not in BLAH[d]:
            continue
        else:
            for v in BLAH[d][k]:
                used[d] = k+v
                foo(used, v)
                try:
                    if check(used):
                        return used
                    else:
                        del used[d]
                except Exception:
                    pass


if __name__ == '__main__':
    print(main())
